# Architect Plugin: Refactoring Plan

## What Changed and Why

**Original model:** Architect generates full spec.md + plan.md per track at decompose time.
**New model:** Architect generates brief.md per track. Conductor generates spec.md + plan.md interactively at implementation time, using the brief as input.

**Why:** Conductor already does interactive spec/plan generation excellently (see VeloTerm example). Architect was duplicating that work AND making it worse by baking in design decisions without developer input. The brief model gives Conductor architectural context it wouldn't otherwise have while preserving the interactive refinement that produces better specs.

---

## Current State (After Original Prompts)

Based on the 6 prompts given to Claude Code, the plugin likely has:

```
architect-plugin/
â”œâ”€â”€ .claude-plugin/plugin.json          âœ… keep as-is
â”œâ”€â”€ commands/
â”‚   â”œâ”€â”€ architect-decompose.md          ğŸ”„ MAJOR REWRITE
â”‚   â”œâ”€â”€ architect-sync.md               ğŸ”„ MODERATE CHANGES
â”‚   â””â”€â”€ architect-status.md             âœ… minor tweaks
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ architect-expert.md             ğŸ”„ MODERATE CHANGES
â”œâ”€â”€ skills/architect/
â”‚   â”œâ”€â”€ SKILL.md                        ğŸ”„ MODERATE CHANGES
â”‚   â”œâ”€â”€ references/
â”‚   â”‚   â”œâ”€â”€ architecture-patterns.md    âœ… keep as-is
â”‚   â”‚   â”œâ”€â”€ cross-cutting-catalog.md    âœ… keep as-is
â”‚   â”‚   â””â”€â”€ classification-guide.md     âœ… keep as-is
â”‚   â””â”€â”€ templates/
â”‚       â”œâ”€â”€ context-header.md           âœ… keep as-is
â”‚       â”œâ”€â”€ context-header-minimal.md   âœ… keep as-is
â”‚       â”œâ”€â”€ architecture.md             âœ… keep as-is
â”‚       â”œâ”€â”€ cross-cutting.md            âœ… keep as-is
â”‚       â”œâ”€â”€ interfaces.md              âœ… keep as-is
â”‚       â”œâ”€â”€ dependency-graph.md         âœ… keep as-is
â”‚       â”œâ”€â”€ execution-sequence.md       âœ… keep as-is
â”‚       â”œâ”€â”€ track-spec.md              âŒ DELETE (Conductor generates specs)
â”‚       â”œâ”€â”€ track-plan.md              âŒ DELETE (Conductor generates plans)
â”‚       â”œâ”€â”€ track-metadata.json         ğŸ”„ SIMPLIFY
â”‚       â”œâ”€â”€ patch-phase.md             âœ… keep as-is (patches still injected by Architect)
â”‚       â””â”€â”€ track-brief.md            â• NEW (the handoff artifact)
â”œâ”€â”€ hooks/project-hooks/
â”‚   â”œâ”€â”€ README.md                       ğŸ”„ MODERATE CHANGES
â”‚   â”œâ”€â”€ constraint-update-check.md      âœ… keep as-is
â”‚   â”œâ”€â”€ interface-verification.md       âœ… keep as-is
â”‚   â”œâ”€â”€ discovery-check.md             âœ… keep as-is
â”‚   â”œâ”€â”€ phase-validation.md            âœ… keep as-is
â”‚   â””â”€â”€ wave-sync.md                   âœ… keep as-is
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ validate_dag.py                âœ… keep as-is
â”‚   â”œâ”€â”€ topological_sort.py            âœ… keep as-is
â”‚   â”œâ”€â”€ inject_context.py             ğŸ”„ MODERATE (generates brief headers, not spec headers)
â”‚   â”œâ”€â”€ merge_discoveries.py           âœ… keep as-is
â”‚   â”œâ”€â”€ sync_check.py                  âœ… keep as-is
â”‚   â”œâ”€â”€ validate_wave_completion.py    âœ… keep as-is
â”‚   â”œâ”€â”€ check_conductor_compat.py      âœ… keep as-is
â”‚   â”œâ”€â”€ progress.py                    âœ… keep as-is
â”‚   â””â”€â”€ regenerate_specs.py           âŒ DELETE (specs not generated by Architect)
â”œâ”€â”€ README.md                          ğŸ”„ UPDATE descriptions
â””â”€â”€ examples/sample-project/           ğŸ”„ UPDATE (briefs not specs)
```

**Summary: ~60% of files are unchanged.** The architecture, cross-cutting, discovery, hooks, scripts, and references are all correct. The change is focused on what gets generated per track.

---

## Detailed Change List

### 1. DELETE: track-spec.md template
**Why:** Architect no longer generates spec.md. Conductor does this interactively.
**Action:** Delete `skills/architect/templates/track-spec.md`

### 2. DELETE: track-plan.md template
**Why:** Architect no longer generates plan.md. Conductor does this from the spec.
**Action:** Delete `skills/architect/templates/track-plan.md`

### 3. DELETE: regenerate_specs.py script
**Why:** No specs to regenerate. The USER ADDITIONS zone concept still applies but
it's in the brief now, and briefs are small enough that regeneration is trivial.
**Action:** Delete `scripts/regenerate_specs.py`

### 4. NEW: track-brief.md template
**Why:** This is the new handoff artifact that Architect generates per track.
**Action:** Create `skills/architect/templates/track-brief.md`

```markdown
<!-- ARCHITECT CONTEXT | Track: {track_id} | Wave: {wave} | CC: {cc_version} -->
## Cross-Cutting Constraints
{filtered_constraints}
## Interfaces
{interfaces_owned_and_consumed}
## Dependencies
{direct_dependencies}
<!-- END ARCHITECT CONTEXT -->

# Track {track_number}: {track_name}

## What This Track Delivers
{one_paragraph_description}

## Scope
IN:
{bulleted_list_of_whats_included}

OUT:
{bulleted_list_of_whats_excluded}

## Key Design Decisions
These should be resolved with the developer during spec generation:
{numbered_list_of_genuine_design_forks}

## Architectural Notes
{2-5_bullets_of_things_the_implementing_agent_needs_to_know}
{future_track_considerations}
{integration_points_and_gotchas}

## Complexity: {S|M|L|XL}
## Estimated Phases: ~{count}
```

### 5. SIMPLIFY: track-metadata.json template
**Why:** No spec/plan to track versions of. Simpler initial state.

FROM:
```json
{
  "track_id": "...",
  "status": "new",
  "complexity": "XL",
  "wave": 4,
  "cc_version_at_start": "v1.0",
  "cc_version_current": "v1.0",
  "dependencies": [],
  "interfaces_owned": [],
  "interfaces_consumed": [],
  "test_command": "...",
  "test_timeout_seconds": 300,
  "patches": [],
  "started_at": null,
  "completed_at": null
}
```

TO:
```json
{
  "track_id": "...",
  "status": "new",
  "complexity": "XL",
  "wave": 4,
  "cc_version_at_brief": "v1.0",
  "cc_version_current": "v1.0",
  "dependencies": [],
  "interfaces_owned": [],
  "interfaces_consumed": [],
  "patches": [],
  "created_at": "...",
  "started_at": null,
  "completed_at": null
}
```

Note: `test_command` and `test_timeout_seconds` are REMOVED from the initial template.
These get added by Conductor when it generates plan.md (Conductor knows the test
framework, Architect doesn't). The validate_wave_completion.py script already handles
the case where test_command is absent (it warns, doesn't fail).

### 6. MAJOR REWRITE: commands/architect-decompose.md

This is the biggest change. The decompose command currently has steps to generate
full spec.md and plan.md per track. These steps are replaced with brief generation.

**What to change in the decompose flow:**

BEFORE (Steps 4-5):
```
Step 4: Generate Architecture (unchanged)
Step 5: Generate All Tracks
  For each track:
  - Generate spec.md with context header + functional requirements
  - Generate plan.md with phased tasks + TDD structure
  - Generate metadata.json
  Update tracks.md
```

AFTER (Steps 4-5):
```
Step 4: Generate Architecture (unchanged)
Step 5: Generate Track Briefs
  For each track:
  - Generate brief.md using track-brief.md template
    - Scope (IN/OUT)
    - Key Design Decisions (the QUESTIONS, not answers)
    - Architectural notes (integration points, future considerations)
    - Filtered cross-cutting constraints
    - Interface contracts this track owns/consumes
  - Generate metadata.json (simplified, no test config)
  Update tracks.md (track registry)
  REVIEW GATE: Developer reviews track list + briefs
```

**Key instruction change in the command:**

Add explicit instruction:
```markdown
## Critical: Brief vs Spec

You are generating BRIEFS, not specs. A brief tells Conductor what
the track is about and what to ask the developer. It does NOT make
design decisions.

WRONG (making decisions):
  "Spawn the user's default shell by reading $SHELL"

RIGHT (identifying the decision):
  "Key Design Decision: Shell spawning â€” $SHELL vs hardcoded? Fallback?"

WRONG (writing functional requirements):
  "FR-1: Dedicated reader thread performs blocking read()..."

RIGHT (scoping the area):
  "IN: PTY spawning and lifecycle management (portable-pty)"
  "Design Decision: Threading model â€” reader-only vs reader+writer?"

The developer will make these choices when Conductor asks them during
implementation. Your job is to identify WHAT needs deciding, not
to decide it.
```

**What stays the same in decompose:**
- Pre-flight checks
- Gap analysis questions
- Architecture research (signal extraction, pattern matching)
- Architecture generation (architecture.md, cross-cutting.md, interfaces.md, etc.)
- Review gates
- Hook installation

### 7. MODERATE CHANGES: commands/architect-sync.md

The sync command currently processes discoveries and generates patches that include
spec/plan modifications. Now:

- NEW_TRACK discovery â†’ generates a brief.md (not spec + plan)
- TRACK_EXTENSION discovery â†’ generates a patch phase appended to plan.md
  (this still works â€” by the time a track needs a patch, Conductor has already
  generated plan.md, so Architect appends to it)
- CROSS_CUTTING_CHANGE â†’ still appends to cross-cutting.md, still updates
  brief context headers for NOT_STARTED tracks

**Specific text changes:**
- Replace "generate spec.md and plan.md" with "generate brief.md"
- Replace "regenerate context headers in spec.md" with "regenerate context
  headers in brief.md" for NOT_STARTED tracks
- For IN_PROGRESS and COMPLETE tracks, the constraint-update-check hook
  still works as designed (it reads cross-cutting.md directly, not the brief)

### 8. MODERATE CHANGES: agents/architect-expert.md

Update the agent's system prompt to reflect the brief model:

- Remove references to generating specs and plans
- Add emphasis on identifying design decisions vs making them
- Add instruction: "Your output per track is a brief â€” scope, decisions,
  constraints, notes. Conductor handles the detailed spec and plan."

### 9. MODERATE CHANGES: skills/architect/SKILL.md

Update:
- Remove references to track-spec.md and track-plan.md templates
- Add reference to track-brief.md template
- Update "What Gets Generated" section:
  ```
  conductor/tracks/{id}/brief.md      â† NEW (Architect's handoff)
  conductor/tracks/{id}/metadata.json â† Simplified
  conductor/tracks/{id}/spec.md       â† Generated by Conductor at pickup
  conductor/tracks/{id}/plan.md       â† Generated by Conductor from spec
  ```
- Remove regenerate_specs.py from scripts list

### 10. MODERATE CHANGES: inject_context.py

This script generates compressed context headers. Currently it targets spec.md.
Now it targets brief.md.

**Changes:**
- Output file: brief.md instead of spec.md
- No USER ADDITIONS zone needed (briefs are fully Architect-owned)
- Simpler output format (brief template, not spec template)
- Still does the same filtering: constraints, interfaces, dependencies
- Still enforces 2000-token cap

### 11. MODERATE CHANGES: hooks/project-hooks/README.md

Update the hook activation table. Currently hooks reference spec.md context headers.
Now:
- Hooks fire during Conductor's implementation (unchanged)
- constraint-update-check reads cross-cutting.md directly (unchanged)
- phase-validation reads cross-cutting.md directly (unchanged)
- The brief's context header is the INITIAL source of constraints;
  once Conductor generates spec.md, the spec's context header is live

Add note:
```markdown
## Context Header Lifecycle
1. Architect generates brief.md with context header
2. Conductor generates spec.md, preserving the context header at top
3. During implementation, hooks read constraints from cross-cutting.md
   directly (not from the header â€” the header is for orientation)
```

### 12. UPDATE: README.md

Update the description of what Architect generates and the workflow diagram.

### 13. UPDATE: examples/sample-project/

If the sample project was generated:
- Replace spec.md files with brief.md files
- Remove plan.md files (these would be Conductor-generated)
- Or add a note: "spec.md and plan.md shown here are examples of what
  Conductor generates from the brief during implementation"

---

## File-Level Change Summary

| File | Action | Effort |
|------|--------|--------|
| templates/track-spec.md | DELETE | trivial |
| templates/track-plan.md | DELETE | trivial |
| scripts/regenerate_specs.py | DELETE | trivial |
| templates/track-brief.md | CREATE | small (~60 lines) |
| commands/architect-decompose.md | REWRITE Steps 5-6 | medium (~100 lines changed) |
| commands/architect-sync.md | UPDATE references | small (~20 lines changed) |
| commands/architect-status.md | UPDATE descriptions | trivial (~5 lines) |
| agents/architect-expert.md | UPDATE system prompt | small (~30 lines changed) |
| skills/architect/SKILL.md | UPDATE references | small (~20 lines changed) |
| templates/track-metadata.json | SIMPLIFY | trivial |
| scripts/inject_context.py | UPDATE target file | small (~15 lines changed) |
| hooks/project-hooks/README.md | ADD lifecycle note | trivial (~10 lines) |
| README.md | UPDATE descriptions | small (~30 lines) |
| examples/sample-project/ | UPDATE or regenerate | medium |

**Total effort: ~300 lines changed across ~12 files.**
**~60% of the plugin is untouched.**

---

## Prompts for Claude Code

### Prompt A: Understand the Change (give context first)

```
Read the design spec in architect-final-design.md, then read this
refactoring rationale:

We discovered that Conductor already does excellent interactive spec
and plan generation. It asks the developer targeted design questions,
confirms the spec, then generates a detailed plan. Architect was
duplicating this AND doing it worse by making design decisions without
developer input.

The change: Architect now generates a "brief" per track instead of
full spec.md and plan.md. The brief contains: scope (IN/OUT), key
design decisions (the QUESTIONS, not answers), cross-cutting constraints,
interface contracts, and architectural notes. When the developer runs
/conductor:implement, Conductor reads the brief and uses it to drive
its own interactive spec generation â€” asking better questions because
it has architectural context.

This means:
- DELETE templates/track-spec.md and templates/track-plan.md
- DELETE scripts/regenerate_specs.py
- CREATE templates/track-brief.md
- REWRITE the track generation steps in commands/architect-decompose.md
- UPDATE references from "spec" to "brief" across ~10 files

Do NOT start making changes yet. First, read every file in the repo
and list all locations where spec.md generation, plan.md generation,
or track-spec/track-plan templates are referenced. I need a complete
impact map before we change anything.
```

### Prompt B: Create the Brief Template

```
Create skills/architect/templates/track-brief.md â€” the new handoff
artifact from Architect to Conductor.

Requirements:
- Starts with ARCHITECT CONTEXT block (constraints, interfaces, dependencies)
- Track name and one-paragraph description
- Scope: IN and OUT lists
- Key Design Decisions: numbered list of genuine design forks
  (the questions Conductor should ask, NOT the answers)
- Architectural Notes: integration points, future track considerations,
  gotchas
- Complexity and estimated phase count

Look at the VeloTerm terminal emulation example for the right level
of detail. The brief for that track would identify 5 design decisions
(shell spawning, threading model, cursor scope, scrollback depth,
selection scope) without answering them.

Also add a section to the template explaining to the generating agent:
"You are identifying decisions, not making them. WRONG: 'Use $SHELL'.
RIGHT: 'Shell spawning: $SHELL vs hardcoded? Fallback behavior?'"
```

### Prompt C: Refactor the Decompose Command

```
Rewrite commands/architect-decompose.md to use the brief model.

The key change is in the track generation steps. Currently it generates
spec.md and plan.md per track. Change to:

For each track:
1. Generate brief.md using templates/track-brief.md
2. Generate metadata.json (simplified â€” no test_command, no test_timeout)
3. DO NOT generate spec.md or plan.md (Conductor does this)

Keep everything else: pre-flight, gap analysis, architecture research,
architecture generation (architecture.md, cross-cutting.md, interfaces.md,
dependency-graph.md, execution-sequence.md), hook installation, review gates.

Add an explicit instruction block titled "Critical: Brief vs Spec" that
tells the agent the difference between identifying decisions and making them.
Include examples of WRONG (making decisions) and RIGHT (identifying them).

Remove any references to track-spec.md or track-plan.md templates.
Reference track-brief.md instead.
```

### Prompt D: Update All References

```
Now update all remaining files that reference spec.md generation,
plan.md generation, or the deleted templates.

Files to update (check each one):
1. commands/architect-sync.md â€” NEW_TRACK generates brief.md not spec+plan
2. commands/architect-status.md â€” description updates
3. agents/architect-expert.md â€” system prompt: generates briefs not specs
4. skills/architect/SKILL.md â€” update template list, scripts list, "What Gets Generated"
5. scripts/inject_context.py â€” target is brief.md not spec.md
6. templates/track-metadata.json â€” remove test_command, test_timeout_seconds
7. hooks/project-hooks/README.md â€” add context header lifecycle note
8. README.md â€” update workflow description

For each file:
- Remove references to track-spec.md, track-plan.md, regenerate_specs.py
- Replace "generate spec.md" with "generate brief.md" where appropriate
- Add note that Conductor generates spec.md and plan.md at implementation time
- Keep all existing functionality that isn't related to spec/plan generation

Delete:
- templates/track-spec.md
- templates/track-plan.md
- scripts/regenerate_specs.py

Commit all changes together with message:
"refactor: brief-based handoff model â€” Architect generates briefs, Conductor generates specs and plans"
```

### Prompt E: Update Sample Project (if exists)

```
If examples/sample-project/ exists, update it:
- Replace any spec.md files in conductor/tracks/*/  with brief.md files
- Remove any plan.md files from conductor/tracks/*/
- Add a note in the example README: "spec.md and plan.md are generated
  by Conductor during /conductor:implement, not by Architect"
- Show 2 example briefs with realistic content matching the sample project

If examples/ doesn't exist yet, skip this â€” we'll generate it later.
```

### Prompt F: Verify and Test

```
Do a full integrity check:

1. Search the entire repo for any remaining references to:
   - "track-spec.md" or "track-plan.md" (should be zero)
   - "regenerate_specs" (should be zero)
   - "generate spec.md" in the context of Architect generating it
     (should be zero â€” only references should be Conductor generating it)
   - "generate plan.md" in the context of Architect generating it
     (should be zero)

2. Verify cross-references:
   - Every file referenced in SKILL.md exists
   - Every template referenced in commands exists
   - Every script referenced in commands/hooks exists

3. Verify the brief template has all required sections:
   - ARCHITECT CONTEXT block
   - Scope IN/OUT
   - Key Design Decisions
   - Architectural Notes
   - Complexity and phase estimate

4. Run syntax check on all Python scripts:
   python -c "import ast; ast.parse(open('scripts/FILE.py').read())"

5. Read commands/architect-decompose.md end-to-end and verify:
   - No step generates spec.md or plan.md
   - Step 5 generates brief.md + metadata.json
   - The "Brief vs Spec" instruction block exists
   - Review gates are present

Report any issues found.
```

---

## Testing Strategy

### Unit-Level (Script Tests)

The Python scripts are largely unaffected. The only script that changes
is inject_context.py, and its core logic (filter constraints, filter
interfaces, enforce token cap) is the same â€” just targeting a different file.

```bash
# Existing tests should still pass
python scripts/validate_dag.py --test  # if self-tests exist
python scripts/topological_sort.py --test
```

### Integration Test (Manual)

After refactoring, test the full flow:

```bash
# 1. Create a test project
mkdir /tmp/test-project && cd /tmp/test-project
git init

# 2. Create minimal Conductor files
mkdir conductor
cat > conductor/product.md << 'EOF'
# Product: TaskFlow
A workflow automation platform for teams.
EOF

cat > conductor/tech-stack.md << 'EOF'
# Tech Stack
- Python 3.12, FastAPI, SQLAlchemy
- React 18, TypeScript, Tailwind
- PostgreSQL 16, Redis
- Docker, docker-compose
EOF

cat > conductor/workflow.md << 'EOF'
# Workflow
Standard Conductor workflow.
EOF

# 3. Install the plugin and run decompose
claude plugin install --path /path/to/architect-plugin
claude
> /architect-decompose
```

**What to verify:**
- [ ] Architect asks gap analysis questions (not design decisions)
- [ ] Architect presents architecture recommendations (3 tiers)
- [ ] Architect generates architecture files (architecture.md, cross-cutting.md, etc.)
- [ ] Architect generates brief.md per track (NOT spec.md or plan.md)
- [ ] Each brief has: scope, key decisions, constraints, notes
- [ ] brief.md key decisions are QUESTIONS not answers
- [ ] metadata.json exists per track (no test_command field)
- [ ] tracks.md registry lists all tracks
- [ ] dependency-graph.md and execution-sequence.md exist
- [ ] hooks/ directory installed with all hook files
- [ ] conductor/workflow.md has ARCHITECT:HOOKS marker

**Then test handoff to Conductor:**
```
> /conductor:implement Track 01
```
- [ ] Conductor reads brief.md and uses it for context
- [ ] Conductor asks interactive design questions (like VeloTerm example)
- [ ] Conductor generates spec.md WITH architect context header preserved
- [ ] Conductor generates plan.md from the spec
- [ ] Implementation proceeds normally with hooks active

---

## What We're NOT Changing

Listing explicitly so nothing gets accidentally broken:

1. âœ… Architecture research phase (signal extraction, pattern matching)
2. âœ… Cross-cutting concern generation and versioning
3. âœ… Interface contract tracking
4. âœ… Dependency graph and wave sequencing
5. âœ… Discovery system (per-file, merge, dedup, conflict detection)
6. âœ… All 5 workflow hooks (unchanged)
7. âœ… Patch injection for retroactive compliance (still appends to plan.md
   AFTER Conductor has generated it)
8. âœ… Wave completion validation
9. âœ… Progress calculation
10. âœ… Reference knowledge base (architecture-patterns, cross-cutting-catalog,
    classification-guide)
11. âœ… Context header format (same ARCHITECT CONTEXT block)
12. âœ… Track state machine (NOT_STARTED â†’ IN_PROGRESS â†’ COMPLETE etc.)
13. âœ… Conductor compatibility checking

---

## Prompt Sequence Summary

| # | Prompt | Purpose | Estimated Time |
|---|--------|---------|----------------|
| A | Impact map | Find all references before changing anything | 5 min |
| B | Create brief template | The new core artifact | 10 min |
| C | Rewrite decompose command | The main behavioral change | 15 min |
| D | Update all references | Cascade changes across ~10 files | 15 min |
| E | Update sample project | If it exists | 10 min |
| F | Verify and test | Catch inconsistencies | 10 min |

**Total: ~1 hour of Claude Code time.**

The refactor is surgical â€” most of the plugin stays exactly as built.
We're removing complexity (no spec/plan generation) and adding one
artifact (the brief template). The architecture, discovery, hooks,
and scripts are all correct as-is.
