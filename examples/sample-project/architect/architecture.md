# System Architecture

> Generated by `/architect-decompose` on 2026-02-07
> Based on: conductor/product.md, conductor/tech-stack.md

---

## System Overview

FlowForge is a workflow automation platform that lets teams build, execute, and monitor multi-step workflows through a visual interface. The system follows a **modular monolith** architecture: a single FastAPI backend deployment with clearly separated internal modules (auth, workflows, execution, events), a React single-page application frontend, and supporting infrastructure (PostgreSQL, Redis, Celery workers).

The backend uses Python 3.12 with FastAPI for the HTTP layer, SQLAlchemy 2.0 async for database access, and Celery with Redis as the distributed task queue for workflow step execution. The frontend is built with React 18 + TypeScript, using React Flow for the drag-and-drop workflow builder. All services are containerized with Docker and orchestrated locally via Docker Compose.

At MVP scale (100 concurrent workflows, 1000 events/minute), the modular monolith provides the simplicity of a single deployment while maintaining internal boundaries that would allow extraction into services later if needed. The transactional outbox pattern ensures reliable event delivery without distributed transactions.

---

## Component Map

```
┌─────────────────────┐
│  React Frontend     │
│  (Vite + TypeScript)│
│  - Workflow Builder  │
│  - Run Monitor       │
│  - Dashboard         │
└──────────┬──────────┘
           │ HTTP (Axios)
           ▼
┌─────────────────────┐       ┌───────────────────┐
│  FastAPI Backend     │──────▶│  PostgreSQL 16     │
│  (Python 3.12)      │       │  - Users           │
│  ┌───────────────┐  │       │  - Workflows       │
│  │ Auth Module   │  │       │  - Runs / Logs     │
│  │ (JWT + RBAC)  │  │       │  - Outbox          │
│  ├───────────────┤  │       └───────────────────┘
│  │ Workflow API  │  │
│  │ (CRUD + Trigs)│  │       ┌───────────────────┐
│  ├───────────────┤  │──────▶│  Redis 7           │
│  │ Execution Svc │  │       │  - Celery Broker   │
│  │ (State Machine│  │       │  - Pub/Sub Events  │
│  ├───────────────┤  │       │  - Cache           │
│  │ Event Bus     │  │       └───────────────────┘
│  │ (Outbox Relay)│  │
│  └───────────────┘  │       ┌───────────────────┐
└──────────┬──────────┘       │  Celery Workers    │
           │ Dispatch         │  (Step Execution)  │
           └─────────────────▶│  - HTTP steps      │
                              │  - Delay steps     │
                              │  - Conditional     │
                              └───────────────────┘

Observability: OTel Collector ──▶ Grafana + Loki (all services instrumented)
```

### Component Responsibilities

| Component | Technology | Responsibility | Key Interfaces |
|-----------|-----------|----------------|----------------|
| React Frontend | React 18 + TypeScript | UI: workflow builder, run monitoring, dashboard | Consumes REST API |
| FastAPI Backend | Python 3.12 + FastAPI | HTTP API, auth, business logic orchestration | Exposes REST API, produces outbox events |
| Auth Module | python-jose + passlib | JWT issuance/validation, RBAC middleware | `GET /v1/auth/me`, `get_current_user` dependency |
| Workflow API | FastAPI routers | CRUD for workflows, triggers, run management | `/v1/workflows/*`, `/v1/runs/*` |
| Execution Service | Celery + custom state machine | Workflow run orchestration, step dispatch, retry | Internal: `execute_workflow(run_id)` |
| Event Bus | Redis pub/sub + outbox relay | Reliable event delivery, pub/sub abstraction | `publish_event()`, Redis channels |
| Celery Workers | Celery 5 + Redis broker | Distributed step execution | Celery tasks per step_type |
| PostgreSQL | PostgreSQL 16 | Persistent storage, outbox | SQLAlchemy models |
| Redis | Redis 7 | Broker, cache, pub/sub | Celery broker, cache-aside, channels |
| OTel + Grafana | OTel Collector + Grafana/Loki | Traces, metrics, log aggregation | OTLP receiver, Grafana dashboards |

---

## Technology Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Architecture style | Modular monolith | MVP scale (100 concurrent) doesn't justify microservices overhead; internal module boundaries allow future extraction |
| Task queue | Celery + Redis | Redis already in stack for caching; Celery provides retry, timeout, and priority out of the box |
| Event delivery | Transactional outbox + Redis pub/sub | Guarantees events are never lost (same DB transaction), Redis pub/sub for fan-out |
| Auth strategy | JWT (access + refresh) | Stateless verification, mobile-friendly, API key as alternative for automation |
| ORM | SQLAlchemy 2.0 async | Async support needed for FastAPI, mature migration tooling (Alembic) |
| Workflow canvas | React Flow | Purpose-built for node-based editors, MIT license, strong community |
| State management | Zustand | Lightweight compared to Redux, sufficient for this scale, good TypeScript support |

---

## Architecture Decision Records

### ADR-001: Modular Monolith Over Microservices

- **Status:** Accepted
- **Date:** 2026-02-07
- **Context:** FlowForge MVP targets 100 concurrent workflows. The team is small and needs to ship fast. Microservices add deployment complexity, distributed tracing overhead, and inter-service communication challenges.
- **Decision:** Use a modular monolith with clear internal boundaries (separate Python packages per module). Define interfaces as if they were service boundaries so extraction is possible later.
- **Consequences:** Simpler deployment and debugging. Risk of module coupling if boundaries aren't maintained. Extraction to services requires work but is feasible since interfaces are defined.

### ADR-002: Transactional Outbox for Event Delivery

- **Status:** Accepted
- **Date:** 2026-02-07
- **Context:** Workflow state changes must reliably publish events (for monitoring, triggers, and future integrations). Dual-write (DB + message broker) can lose events on partial failure. Change Data Capture (CDC) requires additional infrastructure.
- **Decision:** Use the transactional outbox pattern: write events to an outbox table in the same DB transaction as state changes. A relay process polls the outbox and publishes to Redis pub/sub.
- **Consequences:** Events are never lost (transactional guarantee). Adds polling latency (~500ms). Outbox table needs periodic cleanup. Simpler than CDC but less real-time.

### ADR-003: Celery for Workflow Step Execution

- **Status:** Accepted
- **Date:** 2026-02-07
- **Context:** Workflow steps need distributed execution with retry, timeout, and concurrency control. Options: raw asyncio tasks, Celery, Dramatiq, custom queue.
- **Decision:** Use Celery with Redis broker. Each step type registers as a Celery task. Workflow execution creates a Celery canvas (chain/group/chord) matching step topology.
- **Consequences:** Battle-tested retry and timeout handling. Redis broker is already in stack. Celery canvas maps naturally to workflow DAGs. Celery's complexity is worth it for the built-in primitives.

---

## Accepted Architecture Patterns

| Pattern | Tier | Rationale |
|---------|------|-----------|
| Transactional Outbox | Strongly Recommended | Workflow state events must be reliable; prevents dual-write data loss |
| Health Checks | Strongly Recommended | Required for Docker Compose health checks and production readiness |
| Retry with Backoff | Strongly Recommended | Core workflow requirement — steps must retry on transient failures |
| Distributed Tracing | Recommended | OTel for request correlation across backend + workers |
| Rate Limiting | Recommended | Webhook ingestion (1000 events/min) needs throttling |
| Graceful Shutdown | Recommended | Celery workers must finish current step before stopping |
| Circuit Breaker | Consider for Later | External API steps may need circuit breaking under failure |
| CQRS | Consider for Later | Separate read model if dashboard queries become slow |
| Event Sourcing | Consider for Later | Full audit trail may require event sourcing for compliance |

---

## Deferred Pattern Triggers

These patterns were classified as "Consider for Later" during architecture research. They become measurable thresholds in the discovery-check hook.

| Pattern | Trigger Condition | Discovery Classification |
|---------|-------------------|--------------------------|
| Circuit Breaker | External HTTP step failure rate > 10% over 5min | CROSS_CUTTING_CHANGE |
| CQRS | Dashboard/list queries consistently > 500ms | NEW_TRACK |
| Event Sourcing | Compliance/audit requirement emerges for workflow execution history | ARCHITECTURE_CHANGE |
