#!/usr/bin/env python3
"""Regenerate a track's spec.md while preserving USER ADDITIONS content.

Reads the existing spec.md, extracts content between USER ADDITIONS markers,
regenerates the ARCHITECT GENERATED section (context header + spec body),
and writes the result back preserving user's manual additions.

Usage:
    python scripts/regenerate_specs.py --track 04_api_core
    python scripts/regenerate_specs.py --track 04_api_core --tracks-dir conductor/tracks
    python scripts/regenerate_specs.py --track all  # Regenerate all NOT_STARTED tracks

Output (JSON to stdout):
    {
      "track_id": "04_api_core",
      "regenerated": true,
      "user_additions_preserved": true,
      "user_additions_length": 142
    }
"""

import argparse
import json
import re
import subprocess
import sys
from pathlib import Path


USER_ADDITIONS_START = "<!-- USER ADDITIONS"
USER_ADDITIONS_END = "<!-- END USER ADDITIONS -->"
ARCHITECT_GENERATED_START = "<!-- ARCHITECT GENERATED -->"
ARCHITECT_GENERATED_END = "<!-- END ARCHITECT GENERATED -->"
CONTEXT_END = "<!-- END ARCHITECT CONTEXT -->"


def extract_user_additions(spec_text: str) -> str | None:
    """Extract content between USER ADDITIONS markers."""
    pattern = re.compile(
        re.escape(USER_ADDITIONS_START) + r"[^\n]*\n(.*?)" + re.escape(USER_ADDITIONS_END),
        re.DOTALL,
    )
    match = pattern.search(spec_text)
    if match:
        content = match.group(1).strip()
        return content if content else None
    return None


def extract_architect_generated(spec_text: str) -> str | None:
    """Extract content between ARCHITECT GENERATED markers."""
    pattern = re.compile(
        re.escape(ARCHITECT_GENERATED_START) + r"\n(.*?)" + re.escape(ARCHITECT_GENERATED_END),
        re.DOTALL,
    )
    match = pattern.search(spec_text)
    if match:
        return match.group(1)
    return None


def regenerate_context_header(
    track_id: str, tracks_dir: str, architect_dir: str, scripts_dir: str
) -> str | None:
    """Run inject_context.py to regenerate the context header."""
    inject_script = Path(scripts_dir) / "inject_context.py"
    if not inject_script.exists():
        print(f"Warning: inject_context.py not found at {inject_script}", file=sys.stderr)
        return None

    try:
        result = subprocess.run(
            [
                sys.executable, str(inject_script),
                "--track", track_id,
                "--tracks-dir", tracks_dir,
                "--architect-dir", architect_dir,
            ],
            capture_output=True,
            text=True,
            timeout=30,
        )
        if result.returncode == 0:
            output = json.loads(result.stdout)
            return output.get("header")
    except (subprocess.TimeoutExpired, json.JSONDecodeError, OSError) as e:
        print(f"Warning: inject_context.py failed: {e}", file=sys.stderr)

    return None


def rebuild_spec(
    existing_spec: str,
    new_context_header: str | None,
    user_additions: str | None,
) -> str:
    """Rebuild spec.md with new context header, preserving user additions."""
    lines = []

    # 1. Context header (new if available, otherwise keep existing)
    if new_context_header:
        lines.append(new_context_header)
    else:
        # Keep everything up to END ARCHITECT CONTEXT
        idx = existing_spec.find(CONTEXT_END)
        if idx >= 0:
            lines.append(existing_spec[: idx + len(CONTEXT_END)])
        # else no existing context header

    lines.append("")

    # 2. ARCHITECT GENERATED zone (keep existing generated content)
    lines.append(ARCHITECT_GENERATED_START)
    generated = extract_architect_generated(existing_spec)
    if generated:
        lines.append(generated.rstrip())
    else:
        lines.append("<!-- Content regenerated by /architect-decompose -->")
    lines.append(ARCHITECT_GENERATED_END)

    lines.append("")

    # 3. USER ADDITIONS zone (preserved)
    lines.append("<!-- USER ADDITIONS â€” preserved across regenerations -->")
    if user_additions:
        lines.append(user_additions)
    lines.append(USER_ADDITIONS_END)

    return "\n".join(lines) + "\n"


def regenerate_track(
    track_id: str, tracks_dir: str, architect_dir: str, scripts_dir: str
) -> dict:
    """Regenerate a single track's spec.md."""
    spec_path = Path(tracks_dir) / track_id / "spec.md"

    if not spec_path.exists():
        return {
            "track_id": track_id,
            "regenerated": False,
            "reason": "spec.md not found",
        }

    existing = spec_path.read_text()
    user_additions = extract_user_additions(existing)
    new_header = regenerate_context_header(
        track_id, tracks_dir, architect_dir, scripts_dir
    )

    new_spec = rebuild_spec(existing, new_header, user_additions)
    spec_path.write_text(new_spec)

    return {
        "track_id": track_id,
        "regenerated": True,
        "context_header_updated": new_header is not None,
        "user_additions_preserved": user_additions is not None,
        "user_additions_length": len(user_additions) if user_additions else 0,
    }


def main():
    parser = argparse.ArgumentParser(
        description="Regenerate track spec.md preserving USER ADDITIONS"
    )
    parser.add_argument("--track", required=True,
                        help="Track ID, or 'all' to regenerate all NOT_STARTED tracks")
    parser.add_argument("--tracks-dir", default="conductor/tracks",
                        help="Path to conductor tracks directory")
    parser.add_argument("--architect-dir", default="architect",
                        help="Path to architect directory")
    parser.add_argument("--scripts-dir", default="scripts",
                        help="Path to scripts directory (for inject_context.py)")
    parser.add_argument("--force", action="store_true",
                        help="Regenerate even if track is not NOT_STARTED")

    args = parser.parse_args()
    tracks_path = Path(args.tracks_dir)

    if args.track == "all":
        results = []
        for meta_path in sorted(tracks_path.glob("*/metadata.json")):
            try:
                with open(meta_path) as f:
                    meta = json.load(f)
            except (json.JSONDecodeError, OSError):
                continue

            tid = meta["track_id"]
            state = meta.get("state", "NOT_STARTED")

            if state != "NOT_STARTED" and not args.force:
                results.append({
                    "track_id": tid,
                    "regenerated": False,
                    "reason": f"State is {state}, not NOT_STARTED (use --force to override)",
                })
                continue

            results.append(
                regenerate_track(tid, args.tracks_dir, args.architect_dir, args.scripts_dir)
            )

        print(json.dumps({"tracks": results, "total": len(results)}, indent=2))
    else:
        result = regenerate_track(
            args.track, args.tracks_dir, args.architect_dir, args.scripts_dir
        )
        print(json.dumps(result, indent=2))

    sys.exit(0)


if __name__ == "__main__":
    main()
