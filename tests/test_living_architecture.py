#!/usr/bin/env python3
"""Tests for T-LIVING: Living Architecture components.

Tests extract_decisions.py, architecture_updater.py, and the structural
drift detection added to sync_check.py.

Uses unittest (stdlib-only). Run with:
    python -m unittest tests/test_living_architecture.py -v
"""

import json
import subprocess
import sys
import tempfile
import textwrap
import unittest
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(REPO_ROOT / "scripts"))

import architecture_updater as au
import extract_decisions as ed
import sync_check as sc

# --- Sample data ---

SAMPLE_SPEC = textwrap.dedent("""\
    # Track 03: Auth System

    ## Design Decisions

    ### Authentication Strategy
    We chose JWT with RS256 over server-side sessions for stateless verification.
    Using python-jose for JWT handling.

    ### Password Hashing
    Using bcrypt via passlib for password hashing. Considered argon2 but
    bcrypt has better library support in Python.

    ## API Endpoints

    POST /v1/auth/login — Authenticate user
    POST /v1/auth/refresh — Refresh access token
    GET /v1/auth/me — Get current user profile
    DELETE /v1/auth/logout — Invalidate refresh token
""")

SAMPLE_PLAN = textwrap.dedent("""\
    # Implementation Plan

    ## Phase 1: Foundation
    - Install python-jose and passlib
    - Create auth module structure

    ## Phase 2: Implementation
    - Implement JWT token service using RS256 signing
    - Add middleware for request authentication
    - Following repository pattern for user data access

    ## Phase 3: Testing
    - Unit tests for token service
    - Integration tests for auth endpoints
""")

SAMPLE_ARCHITECTURE = textwrap.dedent("""\
    # System Architecture

    > Generated by `/architect-decompose` on 2026-02-07

    ---

    ## System Overview

    A workflow automation platform with modular monolith architecture.

    ---

    ## Component Map

    ### Auth Module
    JWT-based authentication and authorization.
    - Language: Python
    - Framework: FastAPI

    ### API Gateway
    Routes and validates all API requests.
    - Language: Python
    - Framework: FastAPI

    ### Frontend
    React-based single page application.
    - Language: TypeScript
    - Framework: React 18

    ---

    ## Technology Decisions

    | Decision | Choice | Rationale |
    |----------|--------|-----------|
    | Architecture style | Modular monolith | MVP scale |
    | Task queue | Celery + Redis | Already in stack |

    ---

    ## Accepted Architecture Patterns

    | Pattern | Tier | Rationale |
    |---------|------|-----------|
    | Health Checks | Strongly Recommended | Required for readiness |

    ---
""")


class TestExtractDecisions(unittest.TestCase):
    """Test extract_decisions.py functions."""

    def test_extract_technology_decisions(self):
        decisions = ed.extract_technology_decisions(SAMPLE_SPEC, "spec.md")
        chosen_items = [d["chosen"] for d in decisions]
        # Should find "JWT with RS256" chosen over "server-side sessions"
        self.assertTrue(
            any("JWT" in c or "RS256" in c for c in chosen_items),
            f"Expected JWT/RS256 in choices, got: {chosen_items}",
        )

    def test_extract_pattern_decisions(self):
        decisions = ed.extract_pattern_decisions(SAMPLE_PLAN, "plan.md")
        chosen = [d["chosen"] for d in decisions]
        self.assertTrue(
            any("repository" in c.lower() for c in chosen),
            f"Expected 'repository' pattern, got: {chosen}",
        )

    def test_extract_interface_decisions(self):
        decisions = ed.extract_interface_decisions(SAMPLE_SPEC, "spec.md")
        endpoints = [d["chosen"] for d in decisions]
        self.assertIn("/v1/auth/login", endpoints)
        self.assertIn("/v1/auth/me", endpoints)

    def test_extract_rejections(self):
        rejections = ed.extract_rejections(SAMPLE_SPEC)
        self.assertTrue(
            any("session" in r.lower() or "argon2" in r.lower() for r in rejections),
            f"Expected rejection of sessions or argon2, got: {rejections}",
        )

    def test_extract_sections(self):
        sections = ed.extract_sections(SAMPLE_SPEC)
        headings = [s["heading"] for s in sections]
        self.assertIn("Design Decisions", headings)
        self.assertIn("Authentication Strategy", headings)

    def test_is_decision_section(self):
        self.assertTrue(ed.is_decision_section("Design Decisions"))
        self.assertTrue(ed.is_decision_section("Technology Choices"))
        self.assertFalse(ed.is_decision_section("API Endpoints"))

    def test_adr_worthiness_with_alternatives(self):
        decision = {
            "type": "TECHNOLOGY",
            "chosen": "JWT",
            "alternatives_rejected": ["sessions"],
        }
        self.assertTrue(ed.classify_adr_worthiness(decision, []))

    def test_adr_worthiness_pattern(self):
        decision = {"type": "PATTERN", "chosen": "Repository"}
        self.assertTrue(ed.classify_adr_worthiness(decision, []))

    def test_adr_worthiness_interface_not_worthy(self):
        decision = {"type": "INTERFACE", "chosen": "/v1/auth/login"}
        self.assertFalse(ed.classify_adr_worthiness(decision, []))

    def test_generate_adr_slug(self):
        slug = ed.generate_adr_slug({"chosen": "JWT with RS256"})
        self.assertIn("jwt", slug)
        self.assertIn("rs256", slug)

    def test_full_extraction_with_files(self):
        """Integration: extract decisions from temp track directory."""
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "03_auth"
            track_dir.mkdir()
            (track_dir / "spec.md").write_text(SAMPLE_SPEC)
            (track_dir / "plan.md").write_text(SAMPLE_PLAN)

            result = ed.extract_decisions(str(track_dir), str(tmpdir))

            self.assertEqual(result["track_id"], "03_auth")
            self.assertGreater(result["summary"]["total_decisions"], 0)
            self.assertIn("spec.md", result["sources_read"])
            self.assertIn("plan.md", result["sources_read"])

    def test_missing_files_graceful(self):
        """Handles missing spec.md/plan.md gracefully."""
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "empty_track"
            track_dir.mkdir()

            result = ed.extract_decisions(str(track_dir), str(tmpdir))
            self.assertEqual(result["summary"]["total_decisions"], 0)
            self.assertEqual(result["sources_read"], [])

    def test_deduplication(self):
        """Duplicate decisions from multiple sources are deduplicated."""
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "dup_track"
            track_dir.mkdir()
            # Same content in both files
            (track_dir / "spec.md").write_text(SAMPLE_SPEC)
            (track_dir / "brief.md").write_text(SAMPLE_SPEC)

            result = ed.extract_decisions(str(track_dir), str(tmpdir))
            types_and_chosen = [(d["type"], d["chosen"]) for d in result["decisions"]]
            # No exact duplicates
            self.assertEqual(len(types_and_chosen), len(set(types_and_chosen)))


class TestArchitectureUpdater(unittest.TestCase):
    """Test architecture_updater.py functions."""

    def test_generate_patches(self):
        decisions = [
            {"type": "TECHNOLOGY", "chosen": "JWT with RS256",
             "source": "spec.md", "context_line": "Chose JWT over sessions"},
            {"type": "PATTERN", "chosen": "Repository pattern",
             "source": "plan.md", "context_line": "Following repository pattern"},
        ]
        patches = au.generate_architecture_patches(
            decisions, "03_auth", SAMPLE_ARCHITECTURE
        )
        self.assertGreater(len(patches), 0)
        # Should target Technology Decisions and Accepted Architecture Patterns
        sections = [p["section"] for p in patches]
        self.assertIn("## Technology Decisions", sections)
        self.assertIn("## Accepted Architecture Patterns", sections)

    def test_patches_are_additive(self):
        """Patches don't remove existing content."""
        decisions = [
            {"type": "TECHNOLOGY", "chosen": "New Tech",
             "source": "spec.md", "context_line": "test"},
        ]
        patches = au.generate_architecture_patches(
            decisions, "test", SAMPLE_ARCHITECTURE
        )
        updated, _applied = au.apply_patches(SAMPLE_ARCHITECTURE, patches)

        # Original content preserved
        self.assertIn("Modular monolith", updated)
        self.assertIn("Celery + Redis", updated)

    def test_idempotent_patches(self):
        """Applying same patches twice doesn't duplicate."""
        decisions = [
            {"type": "TECHNOLOGY", "chosen": "TestTech",
             "source": "spec.md", "context_line": "test"},
        ]
        patches = au.generate_architecture_patches(
            decisions, "test", SAMPLE_ARCHITECTURE
        )
        updated1, _applied1 = au.apply_patches(SAMPLE_ARCHITECTURE, patches)
        _updated2, applied2 = au.apply_patches(updated1, patches)

        self.assertEqual(len(applied2), 0, "Second application should skip all")

    def test_dry_run_no_writes(self):
        """Dry run doesn't write files."""
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "03_auth"
            track_dir.mkdir()
            (track_dir / "spec.md").write_text(SAMPLE_SPEC)

            arch_dir = Path(tmpdir) / "architect"
            arch_dir.mkdir()
            (arch_dir / "architecture.md").write_text(SAMPLE_ARCHITECTURE)

            au.update_architecture(
                str(track_dir), str(arch_dir), wave=1, dry_run=True
            )

            # No ADR files should be created
            decisions_dir = arch_dir / "decisions"
            if decisions_dir.exists():
                self.assertEqual(len(list(decisions_dir.glob("*.md"))), 0)

    def test_adr_generation(self):
        """ADRs are written to architect/decisions/."""
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "03_auth"
            track_dir.mkdir()
            (track_dir / "spec.md").write_text(SAMPLE_SPEC)

            arch_dir = Path(tmpdir) / "architect"
            arch_dir.mkdir()
            (arch_dir / "architecture.md").write_text(SAMPLE_ARCHITECTURE)

            result = au.update_architecture(
                str(track_dir), str(arch_dir), wave=1, dry_run=False
            )

            # Check ADRs generated
            adrs = result["adrs_generated"]
            written = [a for a in adrs if a["status"] == "written"]
            if written:
                decisions_dir = arch_dir / "decisions"
                self.assertTrue(decisions_dir.exists())
                adr_files = list(decisions_dir.glob("ADR-*.md"))
                self.assertGreater(len(adr_files), 0)

                # Verify ADR content structure
                content = adr_files[0].read_text()
                self.assertIn("## Context", content)
                self.assertIn("## Decision", content)
                self.assertIn("## Consequences", content)

    def test_changelog_generation(self):
        """Changelog entry is appended to CHANGELOG.md."""
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "03_auth"
            track_dir.mkdir()
            (track_dir / "spec.md").write_text(SAMPLE_SPEC)

            arch_dir = Path(tmpdir) / "architect"
            arch_dir.mkdir()
            (arch_dir / "architecture.md").write_text(SAMPLE_ARCHITECTURE)

            result = au.update_architecture(
                str(track_dir), str(arch_dir), wave=1, dry_run=False
            )

            changelog = arch_dir / "CHANGELOG.md"
            self.assertTrue(changelog.exists())
            content = changelog.read_text()
            self.assertIn("03_auth", content)
            self.assertIn("Wave 1", content)

    def test_no_architecture_file(self):
        """Gracefully handles missing architecture.md."""
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "03_auth"
            track_dir.mkdir()
            (track_dir / "spec.md").write_text(SAMPLE_SPEC)

            arch_dir = Path(tmpdir) / "architect"
            arch_dir.mkdir()
            # No architecture.md

            result = au.update_architecture(
                str(track_dir), str(arch_dir), wave=1
            )

            self.assertIn(
                "architecture.md not found",
                " ".join(result["drift_warnings"]),
            )


class TestStructuralDrift(unittest.TestCase):
    """Test structural drift detection in sync_check.py."""

    def test_extract_architecture_components(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            arch_dir = Path(tmpdir)
            (arch_dir / "architecture.md").write_text(SAMPLE_ARCHITECTURE)

            components = sc.extract_architecture_components(str(arch_dir))
            names = [c["name"] for c in components]
            self.assertIn("Auth Module", names)
            self.assertIn("API Gateway", names)
            self.assertIn("Frontend", names)

    def test_no_architecture_file(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            components = sc.extract_architecture_components(tmpdir)
            self.assertEqual(components, [])

    def test_stale_status_detection(self):
        """Detect when architecture says 'planned' but track is completed."""
        with tempfile.TemporaryDirectory() as tmpdir:
            arch_dir = Path(tmpdir)
            (arch_dir / "architecture.md").write_text(SAMPLE_ARCHITECTURE)

            tracks = [
                {
                    "track_id": "03_auth",
                    "status": "completed",
                    "scope": "Auth Module implementation",
                    "boundaries": ["api_layer"],
                },
            ]

            drift = sc.check_structural_drift(tracks, str(arch_dir))
            stale = [d for d in drift if d["type"] == "stale_status"]
            self.assertGreater(len(stale), 0)
            self.assertEqual(stale[0]["component"], "Auth Module")

    def test_no_drift_for_pending_tracks(self):
        """Pending tracks don't trigger stale status drift."""
        with tempfile.TemporaryDirectory() as tmpdir:
            arch_dir = Path(tmpdir)
            (arch_dir / "architecture.md").write_text(SAMPLE_ARCHITECTURE)

            tracks = [
                {
                    "track_id": "03_auth",
                    "status": "pending",
                    "scope": "Auth Module",
                    "boundaries": ["api_layer"],
                },
            ]

            drift = sc.check_structural_drift(tracks, str(arch_dir))
            stale = [d for d in drift if d["type"] == "stale_status"]
            self.assertEqual(len(stale), 0)

    def test_standard_boundaries_not_flagged(self):
        """Standard boundary names (data_model, api_layer etc.) are not
        flagged as undeclared components."""
        with tempfile.TemporaryDirectory() as tmpdir:
            arch_dir = Path(tmpdir)
            (arch_dir / "architecture.md").write_text(SAMPLE_ARCHITECTURE)

            tracks = [
                {
                    "track_id": "01_infra",
                    "status": "in_progress",
                    "scope": "Infrastructure setup",
                    "boundaries": ["infrastructure", "data_model"],
                },
            ]

            drift = sc.check_structural_drift(tracks, str(arch_dir))
            undeclared = [d for d in drift if d["type"] == "undeclared_component"]
            self.assertEqual(len(undeclared), 0)


class TestADRTemplate(unittest.TestCase):
    """Test ADR template format compliance."""

    def test_template_exists(self):
        template_path = REPO_ROOT / "skills" / "architect" / "templates" / "adr.md"
        self.assertTrue(template_path.exists())

    def test_template_has_required_sections(self):
        template_path = REPO_ROOT / "skills" / "architect" / "templates" / "adr.md"
        content = template_path.read_text()
        self.assertIn("## Context", content)
        self.assertIn("## Decision", content)
        self.assertIn("## Alternatives Considered", content)
        self.assertIn("## Consequences", content)

    def test_template_has_placeholders(self):
        template_path = REPO_ROOT / "skills" / "architect" / "templates" / "adr.md"
        content = template_path.read_text()
        self.assertIn("{{NUMBER}}", content)
        self.assertIn("{{TITLE}}", content)
        self.assertIn("{{DATE}}", content)
        self.assertIn("{{TRACK_ID}}", content)


class TestChangelogTemplate(unittest.TestCase):
    """Test changelog template format compliance."""

    def test_template_exists(self):
        template_path = REPO_ROOT / "skills" / "architect" / "templates" / "changelog-entry.md"
        self.assertTrue(template_path.exists())

    def test_template_has_required_sections(self):
        template_path = REPO_ROOT / "skills" / "architect" / "templates" / "changelog-entry.md"
        content = template_path.read_text()
        self.assertIn("Tracks Completed", content)
        self.assertIn("Architecture Changes", content)
        self.assertIn("ADRs Generated", content)


class TestIntegration(unittest.TestCase):
    """Integration tests that run scripts as subprocesses."""

    def _run_script(self, script: str, args: list[str]) -> subprocess.CompletedProcess:
        return subprocess.run(
            [sys.executable, str(REPO_ROOT / "scripts" / script), *args],
            capture_output=True,
            text=True,
        )

    def test_extract_decisions_cli(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "03_auth"
            track_dir.mkdir()
            (track_dir / "spec.md").write_text(SAMPLE_SPEC)

            result = self._run_script("extract_decisions.py", [
                "--track-dir", str(track_dir),
                "--architect-dir", tmpdir,
            ])
            self.assertEqual(result.returncode, 0, f"stderr: {result.stderr}")
            data = json.loads(result.stdout)
            self.assertIn("decisions", data)
            self.assertIn("summary", data)

    def test_architecture_updater_cli_dry_run(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "03_auth"
            track_dir.mkdir()
            (track_dir / "spec.md").write_text(SAMPLE_SPEC)

            arch_dir = Path(tmpdir) / "architect"
            arch_dir.mkdir()
            (arch_dir / "architecture.md").write_text(SAMPLE_ARCHITECTURE)

            result = self._run_script("architecture_updater.py", [
                "--track-dir", str(track_dir),
                "--architect-dir", str(arch_dir),
                "--wave", "1",
                "--dry-run",
            ])
            self.assertEqual(result.returncode, 0, f"stderr: {result.stderr}")
            data = json.loads(result.stdout)
            self.assertTrue(data["dry_run"])
            self.assertIn("decisions_extracted", data)

    def test_architecture_updater_cli_write(self):
        with tempfile.TemporaryDirectory() as tmpdir:
            track_dir = Path(tmpdir) / "03_auth"
            track_dir.mkdir()
            (track_dir / "spec.md").write_text(SAMPLE_SPEC)

            arch_dir = Path(tmpdir) / "architect"
            arch_dir.mkdir()
            (arch_dir / "architecture.md").write_text(SAMPLE_ARCHITECTURE)

            result = self._run_script("architecture_updater.py", [
                "--track-dir", str(track_dir),
                "--architect-dir", str(arch_dir),
                "--wave", "1",
            ])
            self.assertEqual(result.returncode, 0, f"stderr: {result.stderr}")
            data = json.loads(result.stdout)
            self.assertFalse(data["dry_run"])


if __name__ == "__main__":
    unittest.main()
